{"version":3,"file":"411.dccf8ae6.iframe.bundle.js","mappings":";;;AAogBA;;;;;;;;;;;;;AAaA;AACA;;AAEA;;AAGA;;;;AAIA;;;AAGA;;;;;;;;;;;;;AAw8CA;;AAEA","sources":["webpack://cocokits/./node_modules/.pnpm/oniguruma-to-es@0.8.0/node_modules/oniguruma-to-es/dist/index.mjs"],"sourcesContent":["// src/utils.js\nvar cp = String.fromCodePoint;\nvar r = String.raw;\nvar envSupportsDuplicateNames = (() => {\n  try {\n    new RegExp(\"(?<n>)|(?<n>)\");\n  } catch {\n    return false;\n  }\n  return true;\n})();\nvar envSupportsFlagGroups = (() => {\n  try {\n    new RegExp(\"(?i:)\");\n  } catch {\n    return false;\n  }\n  return true;\n})();\nvar envSupportsFlagV = (() => {\n  try {\n    new RegExp(\"\", \"v\");\n  } catch {\n    return false;\n  }\n  return true;\n})();\nfunction getNewCurrentFlags(current, { enable, disable }) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)\n  };\n}\nfunction getOrCreate(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? \"Value expected\");\n  }\n  return value;\n}\n\n// src/options.js\nvar EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018\n};\nvar Target = (\n  /** @type {const} */\n  {\n    auto: \"auto\",\n    ES2025: \"ES2025\",\n    ES2024: \"ES2024\",\n    ES2018: \"ES2018\"\n  }\n);\nfunction getOptions(options) {\n  if (options?.target !== void 0 && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`);\n  }\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: \"default\",\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: \"\",\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // Specifies the recursion depth limit. Supported values are integers `2`–`100` and `null`. If\n    // `null`, any use of recursion results in an error.\n    maxRecursionDepth: 5,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: \"auto\",\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced pattern options that override standard error checking and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Removes unsupported uses of `\\G`, rather than erroring.\n      allowUnhandledGAnchors: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`. Unnamed captures and numbered calls allowed\n      // when using named capture.\n      captureGroup: false,\n      ...options?.rules\n    }\n  };\n  if (opts.target === \"auto\") {\n    opts.target = envSupportsDuplicateNames && envSupportsFlagGroups ? \"ES2025\" : envSupportsFlagV ? \"ES2024\" : \"ES2018\";\n  }\n  return opts;\n}\n\n// src/unicode.js\nvar CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([\n  cp(304),\n  // İ\n  cp(305)\n  // ı\n]);\nfunction getIgnoreCaseMatchChars(char) {\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = /* @__PURE__ */ new Set();\n  const lower = char.toLowerCase();\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\nvar JsUnicodeProperties = /* @__PURE__ */ new Set([\n  // ES2024 general categories and their aliases; all are supported by Oniguruma\n  // See <github.com/mathiasbynens/unicode-match-property-value-ecmascript/blob/main/data/mappings.js>\n  \"C\",\n  \"Other\",\n  \"Cc\",\n  \"Control\",\n  \"cntrl\",\n  \"Cf\",\n  \"Format\",\n  \"Cn\",\n  \"Unassigned\",\n  \"Co\",\n  \"Private_Use\",\n  \"Cs\",\n  \"Surrogate\",\n  \"L\",\n  \"Letter\",\n  \"LC\",\n  \"Cased_Letter\",\n  \"Ll\",\n  \"Lowercase_Letter\",\n  \"Lm\",\n  \"Modifier_Letter\",\n  \"Lo\",\n  \"Other_Letter\",\n  \"Lt\",\n  \"Titlecase_Letter\",\n  \"Lu\",\n  \"Uppercase_Letter\",\n  \"M\",\n  \"Mark\",\n  \"Combining_Mark\",\n  \"Mc\",\n  \"Spacing_Mark\",\n  \"Me\",\n  \"Enclosing_Mark\",\n  \"Mn\",\n  \"Nonspacing_Mark\",\n  \"N\",\n  \"Number\",\n  \"Nd\",\n  \"Decimal_Number\",\n  \"digit\",\n  \"Nl\",\n  \"Letter_Number\",\n  \"No\",\n  \"Other_Number\",\n  \"P\",\n  \"Punctuation\",\n  \"punct\",\n  \"Pc\",\n  \"Connector_Punctuation\",\n  \"Pd\",\n  \"Dash_Punctuation\",\n  \"Pe\",\n  \"Close_Punctuation\",\n  \"Pf\",\n  \"Final_Punctuation\",\n  \"Pi\",\n  \"Initial_Punctuation\",\n  \"Po\",\n  \"Other_Punctuation\",\n  \"Ps\",\n  \"Open_Punctuation\",\n  \"S\",\n  \"Symbol\",\n  \"Sc\",\n  \"Currency_Symbol\",\n  \"Sk\",\n  \"Modifier_Symbol\",\n  \"Sm\",\n  \"Math_Symbol\",\n  \"So\",\n  \"Other_Symbol\",\n  \"Z\",\n  \"Separator\",\n  \"Zl\",\n  \"Line_Separator\",\n  \"Zp\",\n  \"Paragraph_Separator\",\n  \"Zs\",\n  \"Space_Separator\",\n  // ES2024 binary properties and their aliases; all are supported by Oniguruma\n  // See <tc39.es/ecma262/multipage/text-processing.html#table-binary-unicode-properties>\n  \"ASCII\",\n  \"ASCII_Hex_Digit\",\n  \"AHex\",\n  \"Alphabetic\",\n  \"Alpha\",\n  \"Any\",\n  \"Assigned\",\n  \"Bidi_Control\",\n  \"Bidi_C\",\n  \"Bidi_Mirrored\",\n  \"Bidi_M\",\n  \"Case_Ignorable\",\n  \"CI\",\n  \"Cased\",\n  \"Changes_When_Casefolded\",\n  \"CWCF\",\n  \"Changes_When_Casemapped\",\n  \"CWCM\",\n  \"Changes_When_Lowercased\",\n  \"CWL\",\n  \"Changes_When_NFKC_Casefolded\",\n  \"CWKCF\",\n  \"Changes_When_Titlecased\",\n  \"CWT\",\n  \"Changes_When_Uppercased\",\n  \"CWU\",\n  \"Dash\",\n  \"Default_Ignorable_Code_Point\",\n  \"DI\",\n  \"Deprecated\",\n  \"Dep\",\n  \"Diacritic\",\n  \"Dia\",\n  \"Emoji\",\n  \"Emoji_Component\",\n  \"EComp\",\n  \"Emoji_Modifier\",\n  \"EMod\",\n  \"Emoji_Modifier_Base\",\n  \"EBase\",\n  \"Emoji_Presentation\",\n  \"EPres\",\n  \"Extended_Pictographic\",\n  \"ExtPict\",\n  \"Extender\",\n  \"Ext\",\n  \"Grapheme_Base\",\n  \"Gr_Base\",\n  \"Grapheme_Extend\",\n  \"Gr_Ext\",\n  \"Hex_Digit\",\n  \"Hex\",\n  \"IDS_Binary_Operator\",\n  \"IDSB\",\n  \"IDS_Trinary_Operator\",\n  \"IDST\",\n  \"ID_Continue\",\n  \"IDC\",\n  \"ID_Start\",\n  \"IDS\",\n  \"Ideographic\",\n  \"Ideo\",\n  \"Join_Control\",\n  \"Join_C\",\n  \"Logical_Order_Exception\",\n  \"LOE\",\n  \"Lowercase\",\n  \"Lower\",\n  \"Math\",\n  \"Noncharacter_Code_Point\",\n  \"NChar\",\n  \"Pattern_Syntax\",\n  \"Pat_Syn\",\n  \"Pattern_White_Space\",\n  \"Pat_WS\",\n  \"Quotation_Mark\",\n  \"QMark\",\n  \"Radical\",\n  \"Regional_Indicator\",\n  \"RI\",\n  \"Sentence_Terminal\",\n  \"STerm\",\n  \"Soft_Dotted\",\n  \"SD\",\n  \"Terminal_Punctuation\",\n  \"Term\",\n  \"Unified_Ideograph\",\n  \"UIdeo\",\n  \"Uppercase\",\n  \"Upper\",\n  \"Variation_Selector\",\n  \"VS\",\n  \"White_Space\",\n  \"space\",\n  \"XID_Continue\",\n  \"XIDC\",\n  \"XID_Start\",\n  \"XIDS\"\n]);\nvar JsUnicodePropertiesMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodeProperties) {\n  JsUnicodePropertiesMap.set(slug(p), p);\n}\nvar JsUnicodePropertiesOfStrings = /* @__PURE__ */ new Set([\n  // ES2024 properties of strings; none are supported by Oniguruma\n  \"Basic_Emoji\",\n  \"Emoji_Keycap_Sequence\",\n  \"RGI_Emoji\",\n  \"RGI_Emoji_Flag_Sequence\",\n  \"RGI_Emoji_Modifier_Sequence\",\n  \"RGI_Emoji_Tag_Sequence\",\n  \"RGI_Emoji_ZWJ_Sequence\"\n]);\nvar JsUnicodePropertiesOfStringsMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodePropertiesOfStrings) {\n  JsUnicodePropertiesOfStringsMap.set(slug(p), p);\n}\nvar JsUnicodePropertiesPostEs2018 = new Set(\n  // ES2019 scripts\n  \"Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo Extended_Pictographic Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi EBase EComp EMod EPres ExtPict Cpmn Cypro_Minoan Old_Uyghur Ougr Tangsa Tnsa Toto Vith Vithkuqi Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\".split(\" \")\n);\nvar LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([\n  [\"s\", cp(383)],\n  // s, ſ\n  [cp(383), \"s\"]\n  // ſ, s\n]);\nvar LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([\n  [cp(223), cp(7838)],\n  // ß, ẞ\n  [cp(107), cp(8490)],\n  // k, K (Kelvin)\n  [cp(229), cp(8491)],\n  // å, Å (Angstrom)\n  [cp(969), cp(8486)]\n  // ω, Ω (Ohm)\n]);\nvar LowerToTitleCaseMap = new Map([\n  titleEntry(453),\n  titleEntry(456),\n  titleEntry(459),\n  titleEntry(498),\n  ...titleRange(8072, 8079),\n  ...titleRange(8088, 8095),\n  ...titleRange(8104, 8111),\n  titleEntry(8124),\n  titleEntry(8140),\n  titleEntry(8188)\n]);\nvar PosixClassesMap = /* @__PURE__ */ new Map([\n  [\"alnum\", r`[\\p{Alpha}\\p{Nd}]`],\n  [\"alpha\", r`\\p{Alpha}`],\n  [\"ascii\", r`\\p{ASCII}`],\n  [\"blank\", r`[\\p{Zs}\\t]`],\n  [\"cntrl\", r`\\p{cntrl}`],\n  [\"digit\", r`\\p{Nd}`],\n  [\"graph\", r`[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]`],\n  [\"lower\", r`\\p{Lower}`],\n  [\"print\", r`[[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  [\"punct\", r`[\\p{P}\\p{S}]`],\n  // New value from Oniguruma 6.9.9\n  [\"space\", r`\\p{space}`],\n  [\"upper\", r`\\p{Upper}`],\n  [\"word\", r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  [\"xdigit\", r`\\p{AHex}`]\n]);\nvar PosixProperties = /* @__PURE__ */ new Set([\n  \"alnum\",\n  \"blank\",\n  \"graph\",\n  \"print\",\n  \"word\",\n  \"xdigit\"\n  // The following are available with the same name in JS (see `JsUnicodeProperties`), so can be\n  // handled as standard Unicode properties\n  // 'alpha', // (JS: Alpha)\n  // 'ascii', // (JS: ASCII)\n  // 'cntrl', // (JS: cntrl)\n  // 'digit', // (JS: digit)\n  // 'lower', // (JS: Lower)\n  // 'punct', // (JS: punct)\n  // 'space', // (JS: space)\n  // 'upper', // (JS: Upper)\n]);\nfunction range(start, end) {\n  const range2 = [];\n  for (let i = start; i <= end; i++) {\n    range2.push(i);\n  }\n  return range2;\n}\nfunction slug(name) {\n  return name.replace(/[- _]+/g, \"\").toLowerCase();\n}\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\nfunction titleRange(start, end) {\n  return range(start, end).map((codePoint) => titleEntry(codePoint));\n}\nvar UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([\n  \"Lower\",\n  \"Lowercase\",\n  \"Upper\",\n  \"Uppercase\",\n  \"Ll\",\n  \"Lowercase_Letter\",\n  \"Lt\",\n  \"Titlecase_Letter\",\n  \"Lu\",\n  \"Uppercase_Letter\"\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\n// src/tokenize.js\nvar TokenTypes = (\n  /** @type {const} */\n  {\n    Alternator: \"Alternator\",\n    Assertion: \"Assertion\",\n    Backreference: \"Backreference\",\n    Character: \"Character\",\n    CharacterClassClose: \"CharacterClassClose\",\n    CharacterClassHyphen: \"CharacterClassHyphen\",\n    CharacterClassIntersector: \"CharacterClassIntersector\",\n    CharacterClassOpen: \"CharacterClassOpen\",\n    CharacterSet: \"CharacterSet\",\n    Directive: \"Directive\",\n    GroupClose: \"GroupClose\",\n    GroupOpen: \"GroupOpen\",\n    Subroutine: \"Subroutine\",\n    Quantifier: \"Quantifier\",\n    // These aren't allowed in char classes, so they aren't equivalent to JS `[\\q{}]`\n    VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n    // Intermediate representation not included in results\n    EscapedNumber: \"EscapedNumber\"\n  }\n);\nvar TokenCharacterSetKinds = {\n  any: \"any\",\n  digit: \"digit\",\n  dot: \"dot\",\n  hex: \"hex\",\n  non_newline: \"non_newline\",\n  posix: \"posix\",\n  property: \"property\",\n  space: \"space\",\n  word: \"word\"\n};\nvar TokenDirectiveKinds = {\n  flags: \"flags\",\n  keep: \"keep\"\n};\nvar TokenGroupKinds = {\n  atomic: \"atomic\",\n  capturing: \"capturing\",\n  group: \"group\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\"\n};\nvar EscapeCharCodes = /* @__PURE__ */ new Map([\n  [\"a\", 7],\n  // alert/bell (Not available in JS)\n  [\"b\", 8],\n  // backspace (only in char classes)\n  [\"e\", 27],\n  // escape (Not available in JS)\n  [\"f\", 12],\n  // form feed\n  [\"n\", 10],\n  // line feed\n  [\"r\", 13],\n  // carriage return\n  [\"t\", 9],\n  // horizontal tab\n  [\"v\", 11]\n  // vertical tab\n]);\nvar charClassOpenPattern = r`\\[\\^?`;\nvar sharedEscapesPattern = `${// Control char\n\"c.? | C(?:-.?)?\"}|${// Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n// `\\p{gc=L}` are invalid\nr`[pP]\\{(?:\\^?[\\x20\\w]+\\})?`}|${// Hex encoded byte sequence; attempt match before other `\\xNN` hex char\nr`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`}|${// Hex char\nr`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`}|${// Enclosed octal code point\nr`o\\{[^\\}]*\\}?`}|${// Escaped number\nr`\\d{1,3}`}`;\nvar quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nvar tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?: \\? (?:\n    [:=!>(~]\n    | <[=!]\n    | <[^>]*>\n    | '[^']*'\n    | # (?:[^)\\\\] | \\\\.?)*\n    | [imx\\-]+[:)]\n  )?)?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nvar charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:[^:]*:\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nfunction tokenize(pattern, flags = \"\", rules) {\n  rules = {\n    // `ONIG_OPTION_CAPTURE_GROUP`\n    captureGroup: false,\n    ...rules\n  };\n  if (typeof pattern !== \"string\") {\n    throw new Error(\"String expected as pattern\");\n  }\n  if (!/^[imxDSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const extended = flags.includes(\"x\");\n  const xStack = [extended];\n  const context = {\n    captureGroup: rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {\n      xStack.pop();\n    },\n    pushModX(isXOn) {\n      xStack.push(isXOn);\n    },\n    replaceCurrentModX(isXOn) {\n      xStack[xStack.length - 1] = isXOn;\n    }\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while (match = tokenRe.exec(pattern)) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== void 0) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach((t) => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === \"(\") {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  tokens = tokens.map(\n    (t) => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n  return {\n    tokens,\n    flags: {\n      ignoreCase: flags.includes(\"i\"),\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      dotAll: flags.includes(\"m\"),\n      // Flag x is fully handled during tokenization\n      extended,\n      // Flags D, S, W are currently only supported as top-level flags\n      digitIsAscii: flags.includes(\"D\"),\n      spaceIsAscii: flags.includes(\"S\"),\n      wordIsAscii: flags.includes(\"W\")\n    },\n    rules\n  };\n}\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1, m2] = m;\n  if (m0 === \"[\") {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex\n    };\n  }\n  if (m0 === \"\\\\\") {\n    if (\"AbBGzZ\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m\n        })\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m)\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m)\n      };\n    }\n    if (m1 === \"K\") {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep\n        })\n      };\n    }\n    if (m1 === \"N\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.non_newline\n        })\n      };\n    }\n    if (m1 === \"O\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any\n        })\n      };\n    }\n    if (\"RX\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.VariableLengthCharacterSet, m, {\n          kind: m\n        })\n      };\n    }\n    if (\"yY\".includes(m1)) {\n      throw new Error(`Unsupported grapheme boundary \"${m}\"`);\n    }\n    const result = createTokenForSharedEscape(m, { inCharClass: false });\n    return Array.isArray(result) ? { tokens: result } : { token: result };\n  }\n  if (m0 === \"(\") {\n    if (m2 === \"#\") {\n      if (pattern[lastIndex] !== \")\") {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        lastIndex: lastIndex + 1\n      };\n    }\n    if (\"-imx\".includes(m2)) {\n      return {\n        token: createTokenForFlagMod(m, context)\n      };\n    }\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      m === \"(\" && !context.captureGroup || // Noncapturing group\n      m === \"(?:\"\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group\n        })\n      };\n    }\n    if (m === \"(?>\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic\n        })\n      };\n    }\n    if (m === \"(?=\" || m === \"(?!\" || m === \"(?<=\" || m === \"(?<!\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m2 === \"<\" ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith(\"!\")\n        })\n      };\n    }\n    if (m2 === \"<\" || m2 === \"'\" || m === \"(\" && context.captureGroup) {\n      const token2 = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing\n        // Will add `number` in a second pass\n      });\n      if (m !== \"(\") {\n        token2.name = m.slice(3, -1);\n      }\n      return {\n        token: token2\n      };\n    }\n    if (m2 === \"(\") {\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    if (m2 === \"~\") {\n      throw new Error(`Unsupported absence operator \"${m}\"`);\n    }\n    if (m === \"(?\") {\n      throw new Error(\"Invalid group\");\n    }\n    throw new Error(`Unexpected group \"${m}\"`);\n  }\n  if (m === \")\") {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m)\n    };\n  }\n  if (m === \"#\" && context.getCurrentModX()) {\n    const end = pattern.indexOf(\"\\n\", lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex\n    };\n  }\n  if (m === \".\") {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot\n      })\n    };\n  }\n  if (m === \"^\" || m === \"$\") {\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind: m\n      })\n    };\n  }\n  if (m === \"|\") {\n    return {\n      token: createToken(TokenTypes.Alternator, m)\n    };\n  }\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m)\n    };\n  }\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0)\n    })\n  };\n}\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === \"^\"\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while (match = charClassTokenRe.exec(pattern)) {\n    const m = match[0];\n    if (m[0] === \"[\" && m[1] !== \":\") {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === \"^\"\n      }));\n    } else if (m === \"]\") {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length\n  };\n}\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === \"\\\\\") {\n    return createTokenForSharedEscape(raw, { inCharClass: true });\n  }\n  if (raw[0] === \"[\") {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassesMap.get(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      negate: !!posix.groups.negate,\n      value: posix.groups.name\n    });\n  }\n  if (raw === \"-\") {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === \"&&\") {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0)\n  });\n}\nfunction createTokenForSharedEscape(raw, { inCharClass }) {\n  const char1 = raw[1];\n  if (char1 === \"c\" || char1 === \"C\") {\n    return createTokenForControlChar(raw);\n  }\n  if (\"dDhHsSwW\".includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(\"Incomplete or invalid Unicode property\");\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map((hex) => parseInt(hex, 16));\n      const decoded = new TextDecoder(\"utf-8\", {\n        ignoreBOM: true,\n        fatal: true\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map((char) => {\n        const raw2 = [...encoder.encode(char)].map((byte) => `\\\\x${byte.toString(16)}`).join(\"\");\n        return createToken(TokenTypes.Character, raw2, {\n          value: char.codePointAt(0)\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === \"u\" || char1 === \"x\") {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw)\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1)\n    });\n  }\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass\n    });\n  }\n  if (raw === \"\\\\\") {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  if (char1 === \"M\") {\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1)\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data\n  };\n}\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === \"c\" ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64\n  });\n}\nfunction createTokenForFlagMod(raw, context) {\n  let { on, off } = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[imx\\-]*))?/.exec(raw).groups;\n  off ??= \"\";\n  const isXOn = (context.getCurrentModX() || on.includes(\"x\")) && !off.includes(\"x\");\n  const enabledFlags = getFlagPropsForToken(on);\n  const disabledFlags = getFlagPropsForToken(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  if (raw.endsWith(\")\")) {\n    context.replaceCurrentModX(isXOn);\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges\n    });\n  }\n  if (raw.endsWith(\":\")) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token2 = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group\n    });\n    if (enabledFlags || disabledFlags) {\n      token2.flags = flagChanges;\n    }\n    return token2;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === \"{\") {\n    const { min, max } = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 1e5;\n    if (+min > limit || +max > limit) {\n      throw new Error(\"Quantifier value unsupported in Oniguruma\");\n    }\n    data.min = +min;\n    data.max = max === void 0 ? +min : max === \"\" ? Infinity : +max;\n    data.greedy = !raw.endsWith(\"?\");\n    data.possessive = false;\n  } else {\n    data.min = raw[0] === \"+\" ? 1 : 0;\n    data.max = raw[0] === \"?\" ? 1 : Infinity;\n    data.greedy = raw[1] !== \"?\";\n    data.possessive = raw[1] === \"+\";\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      \"d\": TokenCharacterSetKinds.digit,\n      \"h\": TokenCharacterSetKinds.hex,\n      // Not available in JS\n      \"s\": TokenCharacterSetKinds.space,\n      // Different than JS\n      \"w\": TokenCharacterSetKinds.word\n    }[lower],\n    negate: raw[1] !== lower\n  });\n}\nfunction createTokenForUnicodeProperty(raw) {\n  const { p, neg, value } = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[ \\w]+)/.exec(raw).groups;\n  const negate = p === \"P\" && !neg || p === \"p\" && !!neg;\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    negate,\n    value\n  });\n}\nfunction getFlagPropsForToken(flags) {\n  const obj = {};\n  if (flags.includes(\"i\")) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes(\"m\")) {\n    obj.dotAll = true;\n  }\n  if (flags.includes(\"x\")) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\nfunction getValidatedHexCharCode(raw) {\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  const hex = raw[2] === \"{\" ? /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex : raw.slice(2);\n  const dec = parseInt(hex, 16);\n  if (dec > 1310719) {\n    throw new Error(`Invalid out of range \"${raw}\"`);\n  } else if (dec > 1114111) {\n    throw new Error(`Invalid out of range in JS \"${raw}\"`);\n  }\n  return dec;\n}\nfunction splitEscapedNumToken(token2, numCaptures) {\n  const { raw, inCharClass } = token2;\n  const value = raw.slice(1);\n  if (!inCharClass && // Single digit 1-9 outside a char class is always treated as a backref\n  (value !== \"0\" && value.length === 1 || // Leading 0 makes it octal; backrefs can't include following literal digits\n  value[0] !== \"0\" && +value <= numCaptures)) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value2;\n    if (i === 0 && m !== \"8\" && m !== \"9\") {\n      value2 = parseInt(m, 8);\n      if (value2 > 127) {\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value2 = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? \"\\\\\" : \"\") + m, {\n      value: value2\n    }));\n  }\n  return tokens;\n}\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\n// src/utils-node.js\nfunction hasOnlyChild({ alternatives }, kidFn) {\n  return alternatives.length === 1 && alternatives[0].elements.length === 1 && (!kidFn || kidFn(alternatives[0].elements[0]));\n}\nfunction isLookaround({ type, kind }) {\n  return type === AstTypes.Assertion && (kind === AstAssertionKinds.lookahead || kind === AstAssertionKinds.lookbehind);\n}\nfunction isZeroLengthNode({ type, min }) {\n  return type === AstTypes.Assertion || type === AstTypes.Directive || type === AstTypes.Quantifier && !min;\n}\n\n// src/traverse.js\nfunction traverse(path, state, visitor) {\n  let ast = path.node;\n  while (ast.parent) {\n    ast = ast.parent;\n  }\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path2 = {\n      node,\n      parent,\n      key,\n      container,\n      ast,\n      remove() {\n        throwIfNot(container, \"Container expected\").splice(Math.max(0, key + keyShift), 1);\n        keyShift -= 1;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, \"Container expected\").splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, \"Container expected\").splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode) {\n        setParent(newNode, parent);\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      }\n    };\n    const visitorKey = getAstTypeAliases(node).find((key2) => !!visitor[key2]);\n    const methods = visitorKey && visitor[visitorKey];\n    const enterFn = typeof methods === \"function\" ? methods : methods?.enter;\n    const exitFn = methods?.exit;\n    enterFn?.(path2, state);\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case AstTypes.Regex:\n          traverseNode(node.pattern, node, \"pattern\");\n          traverseNode(node.flags, node, \"flags\");\n          break;\n        case AstTypes.Alternative:\n        case AstTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case AstTypes.Assertion:\n          if (isLookaround(node)) {\n            traverseArray(node.alternatives, node);\n          }\n          break;\n        case AstTypes.Backreference:\n        case AstTypes.Character:\n        case AstTypes.CharacterSet:\n        case AstTypes.Directive:\n        case AstTypes.Flags:\n        case AstTypes.Recursion:\n        case AstTypes.Subroutine:\n        case AstTypes.VariableLengthCharacterSet:\n          break;\n        case AstTypes.CapturingGroup:\n        case AstTypes.Group:\n        case AstTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case AstTypes.CharacterClassIntersection:\n          traverseArray(node.classes, node);\n          break;\n        case AstTypes.CharacterClassRange:\n          traverseNode(node.min, node, \"min\");\n          traverseNode(node.max, node, \"max\");\n          break;\n        case AstTypes.Quantifier:\n          traverseNode(node.element, node, \"element\");\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n    exitFn?.(path2, state);\n    return keyShift;\n  }\n  traverseNode(path.node, path.parent, path.key, path.container);\n}\nvar AstTypeAliases = {\n  AnyGroup: \"AnyGroup\",\n  AnyNode: \"AnyNode\"\n};\nfunction getAstTypeAliases(node) {\n  const { type } = node;\n  const types = [AstTypeAliases.AnyNode];\n  if (type === AstTypes.CapturingGroup || type === AstTypes.Group || isLookaround(node)) {\n    types.push(AstTypeAliases.AnyGroup);\n  }\n  types.push(type);\n  return types;\n}\nfunction setParent(node, parent) {\n  if (\"parent\" in parent) {\n    node.parent = parent;\n  }\n}\n\n// src/parse.js\nvar AstTypes = {\n  Alternative: \"Alternative\",\n  Assertion: \"Assertion\",\n  Backreference: \"Backreference\",\n  CapturingGroup: \"CapturingGroup\",\n  Character: \"Character\",\n  CharacterClass: \"CharacterClass\",\n  CharacterClassIntersection: \"CharacterClassIntersection\",\n  CharacterClassRange: \"CharacterClassRange\",\n  CharacterSet: \"CharacterSet\",\n  Directive: \"Directive\",\n  Flags: \"Flags\",\n  Group: \"Group\",\n  Pattern: \"Pattern\",\n  Quantifier: \"Quantifier\",\n  Regex: \"Regex\",\n  Subroutine: \"Subroutine\",\n  VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n  // Used only by the transformer for Regex+ ASTs\n  Recursion: \"Recursion\"\n};\nvar AstAssertionKinds = {\n  line_end: \"line_end\",\n  line_start: \"line_start\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\",\n  search_start: \"search_start\",\n  string_end: \"string_end\",\n  string_end_newline: \"string_end_newline\",\n  string_start: \"string_start\",\n  word_boundary: \"word_boundary\"\n};\nvar AstCharacterSetKinds = TokenCharacterSetKinds;\nvar AstDirectiveKinds = TokenDirectiveKinds;\nvar AstVariableLengthCharacterSetKinds = {\n  grapheme: \"grapheme\",\n  newline: \"newline\"\n};\nfunction parse({ tokens, flags, rules }, options) {\n  const opts = {\n    skipBackrefValidation: false,\n    skipPropertyNameValidation: false,\n    verbose: false,\n    ...options\n  };\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: /* @__PURE__ */ new Map(),\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens,\n    verbose: opts.verbose,\n    walk\n  };\n  function walk(parent, state) {\n    const token2 = tokens[context.current];\n    context.parent = parent;\n    context.token = token2;\n    context.current++;\n    switch (token2.type) {\n      case TokenTypes.Alternator:\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token2);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token2.value);\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirectiveFromToken(token2);\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      case TokenTypes.VariableLengthCharacterSet:\n        return createVariableLengthCharacterSet(token2.kind);\n      default:\n        throw new Error(`Unexpected token type \"${token2.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokens.length) {\n    const node = walk(top, {});\n    if (node.type === AstTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  const { capturingGroups, hasNumberedRef, namedGroupsByName, subroutines } = context;\n  if (hasNumberedRef && namedGroupsByName.size && !rules.captureGroup) {\n    throw new Error(\"Numbered backref/subroutine not allowed when using named capture\");\n  }\n  for (const { ref } of subroutines) {\n    if (typeof ref === \"number\") {\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  traverse({ node: ast }, null, {\n    AnyNode({ node, parent }) {\n      node.parent = parent;\n    }\n  });\n  return ast;\n}\nfunction parseBackreference(context) {\n  const { raw } = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    if (num > numCapturesToLeft) {\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, { orphan });\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\nfunction parseCharacterClassHyphen(context, state) {\n  const { parent, tokens, walk } = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (prevSiblingNode && prevSiblingNode.type !== AstTypes.CharacterClass && prevSiblingNode.type !== AstTypes.CharacterClassRange && nextToken && nextToken.type !== TokenTypes.CharacterClassOpen && nextToken.type !== TokenTypes.CharacterClassClose && nextToken.type !== TokenTypes.CharacterClassIntersector) {\n    const nextNode = walk(parent, state);\n    if (prevSiblingNode.type === AstTypes.Character && nextNode.type === AstTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error(\"Invalid character class range\");\n  }\n  return createCharacter(45);\n}\nfunction parseCharacterClassOpen(context, state) {\n  const { token: token2, tokens, verbose, walk } = context;\n  const firstClassToken = tokens[context.current];\n  let node = createCharacterClass({ negate: token2.negate });\n  const intersection = node.elements[0];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersection.classes.push(createCharacterClass({ negate: false, baseOnly: true }));\n      context.current++;\n    } else {\n      const cc = intersection.classes.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  if (!verbose) {\n    optimizeCharacterClassIntersection(intersection);\n  }\n  if (intersection.classes.length === 1) {\n    const cc = intersection.classes[0];\n    cc.negate = node.negate !== cc.negate;\n    node = cc;\n  }\n  context.current++;\n  return node;\n}\nfunction parseCharacterSet({ token: token2, skipPropertyNameValidation }) {\n  let { kind, negate, value } = token2;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    if (PosixProperties.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        skipPropertyNameValidation\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return {\n      type: AstTypes.CharacterSet,\n      kind: AstCharacterSetKinds.posix,\n      negate,\n      value\n    };\n  }\n  return createCharacterSet(kind, { negate });\n}\nfunction parseGroupOpen(context, state) {\n  const { token: token2, tokens, capturingGroups, namedGroupsByName, verbose, walk } = context;\n  let node = createByGroupKind(token2);\n  if (node.type === AstTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrCreate(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      alt.elements.push(walk(alt, state));\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  if (!verbose) {\n    node = getOptimizedGroup(node);\n  }\n  context.current++;\n  return node;\n}\nfunction parseQuantifier({ token: token2, parent }) {\n  const { min, max, greedy, possessive: possessive2 } = token2;\n  const quantifiedNode = parent.elements.at(-1);\n  if (!quantifiedNode || quantifiedNode.type === AstTypes.Assertion || quantifiedNode.type === AstTypes.Directive) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(quantifiedNode, min, max, greedy, possessive2);\n  parent.elements.pop();\n  return node;\n}\nfunction parseSubroutine(context) {\n  const { token: token2, capturingGroups, subroutines } = context;\n  let ref = token2.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      \"\": num,\n      \"+\": numCapturesToLeft + num,\n      \"-\": numCapturesToLeft + 1 - num\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error(\"Invalid subroutine number\");\n    }\n  } else if (ref === \"0\") {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\nfunction createAlternative() {\n  return {\n    type: AstTypes.Alternative,\n    elements: []\n  };\n}\nfunction createAssertionFromToken({ type, kind, negate }) {\n  if (type === TokenTypes.GroupOpen) {\n    return createLookaround({\n      behind: kind === TokenGroupKinds.lookbehind,\n      negate\n    });\n  }\n  const nodeKind = throwIfNot({\n    \"^\": AstAssertionKinds.line_start,\n    \"$\": AstAssertionKinds.line_end,\n    \"\\\\A\": AstAssertionKinds.string_start,\n    \"\\\\b\": AstAssertionKinds.word_boundary,\n    \"\\\\B\": AstAssertionKinds.word_boundary,\n    \"\\\\G\": AstAssertionKinds.search_start,\n    \"\\\\z\": AstAssertionKinds.string_end,\n    \"\\\\Z\": AstAssertionKinds.string_end_newline\n  }[kind], `Unexpected assertion kind \"${kind}\"`);\n  const node = {\n    type: AstTypes.Assertion,\n    kind: nodeKind\n  };\n  if (nodeKind === AstAssertionKinds.word_boundary) {\n    node.negate = kind === r`\\B`;\n  }\n  return node;\n}\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: AstTypes.Backreference,\n    ...orphan && { orphan },\n    ref\n  };\n}\nfunction createByGroupKind(token2) {\n  const { kind, number, name, flags } = token2;\n  switch (kind) {\n    case TokenGroupKinds.atomic:\n      return createGroup({ atomic: true });\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({ flags });\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createAssertionFromToken(token2);\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== void 0;\n  if (hasName && !isValidGroupNameOniguruma(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: AstTypes.CapturingGroup,\n    number,\n    ...hasName && { name },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createCharacter(charCode) {\n  return {\n    type: AstTypes.Character,\n    value: charCode\n  };\n}\nfunction createCharacterClass(options) {\n  const opts = {\n    baseOnly: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterClass,\n    negate: opts.negate,\n    elements: opts.baseOnly ? [] : [createCharacterClassIntersection()]\n  };\n}\nfunction createCharacterClassIntersection() {\n  return {\n    type: AstTypes.CharacterClassIntersection,\n    classes: [createCharacterClass({ negate: false, baseOnly: true })]\n  };\n}\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error(\"Character class range out of order\");\n  }\n  return {\n    type: AstTypes.CharacterClassRange,\n    min,\n    max\n  };\n}\nfunction createCharacterSet(kind, { negate }) {\n  const node = {\n    type: AstTypes.CharacterSet,\n    kind: throwIfNot(AstCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`)\n  };\n  if (kind === TokenCharacterSetKinds.digit || kind === TokenCharacterSetKinds.hex || kind === TokenCharacterSetKinds.space || kind === TokenCharacterSetKinds.word) {\n    node.negate = negate;\n  }\n  return node;\n}\nfunction createDirectiveFromToken({ kind, flags }) {\n  const node = {\n    type: AstTypes.Directive,\n    kind: throwIfNot(AstDirectiveKinds[kind], `Unexpected directive kind \"${kind}\"`)\n  };\n  if (kind === TokenDirectiveKinds.flags) {\n    node.flags = flags;\n  }\n  return node;\n}\nfunction createFlags({ ignoreCase, dotAll, extended, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n  return {\n    type: AstTypes.Flags,\n    ignoreCase,\n    dotAll,\n    extended,\n    digitIsAscii,\n    spaceIsAscii,\n    wordIsAscii\n  };\n}\nfunction createGroup(options) {\n  const atomic2 = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: AstTypes.Group,\n    ...atomic2 && { atomic: atomic2 },\n    ...flags && { flags },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createLookaround(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.Assertion,\n    kind: opts.behind ? AstAssertionKinds.lookbehind : AstAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createPattern() {\n  return {\n    type: AstTypes.Pattern,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createQuantifier(element, min, max, greedy, possessive2) {\n  if (max < min) {\n    throw new Error(\"Quantifier range out of order\");\n  }\n  const node = {\n    type: AstTypes.Quantifier,\n    min,\n    max,\n    greedy,\n    possessive: possessive2,\n    element\n  };\n  return node;\n}\nfunction createRegex(pattern, flags) {\n  return {\n    type: AstTypes.Regex,\n    pattern,\n    flags\n  };\n}\nfunction createSubroutine(ref) {\n  return {\n    type: AstTypes.Subroutine,\n    ref\n  };\n}\nfunction createUnicodeProperty(value, options) {\n  const opts = {\n    negate: false,\n    skipPropertyNameValidation: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterSet,\n    kind: AstCharacterSetKinds.property,\n    value: opts.skipPropertyNameValidation ? value : getJsUnicodePropertyName(value),\n    negate: opts.negate\n  };\n}\nfunction createVariableLengthCharacterSet(kind) {\n  return {\n    type: AstTypes.VariableLengthCharacterSet,\n    kind: throwIfNot({\n      \"\\\\R\": AstVariableLengthCharacterSetKinds.newline,\n      \"\\\\X\": AstVariableLengthCharacterSetKinds.grapheme\n    }[kind], `Unexpected varcharset kind \"${kind}\"`)\n  };\n}\nfunction getJsUnicodePropertyName(value) {\n  const slugged = slug(value);\n  if (JsUnicodePropertiesOfStringsMap.has(slugged)) {\n    throw new Error(r`Unicode property \"\\p{${value}}\" unsupported in Oniguruma`);\n  }\n  const jsName = JsUnicodePropertiesMap.get(slugged);\n  if (jsName) {\n    return jsName;\n  }\n  return value.trim().replace(/\\s+/g, \"_\").replace(/[A-Z][a-z]+(?=[A-Z])/g, \"$&_\").replace(/[A-Za-z]+/g, (m) => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\nfunction getOptimizedGroup(node) {\n  const firstAltFirstEl = node.alternatives[0].elements[0];\n  if (node.type === AstTypes.Group && hasOnlyChild(node, (kid) => kid.type === AstTypes.Group) && !(node.atomic && firstAltFirstEl.flags) && !(node.flags && (firstAltFirstEl.atomic || firstAltFirstEl.flags))) {\n    if (node.atomic) {\n      firstAltFirstEl.atomic = true;\n    } else if (node.flags) {\n      firstAltFirstEl.flags = node.flags;\n    }\n    return firstAltFirstEl;\n  }\n  return node;\n}\nfunction isValidGroupNameOniguruma(name) {\n  return !/^(?:[-\\d]|$)/.test(name);\n}\nfunction optimizeCharacterClassIntersection(intersection) {\n  for (let i = 0; i < intersection.classes.length; i++) {\n    const cc = intersection.classes[i];\n    const firstChild = cc.elements[0];\n    if (cc.elements.length === 1 && firstChild.type === AstTypes.CharacterClass) {\n      intersection.classes[i] = firstChild;\n      firstChild.negate = cc.negate !== firstChild.negate;\n    }\n  }\n}\nfunction throwIfUnclosedCharacterClass(token2, firstClassToken) {\n  return throwIfNot(\n    token2,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? \"Empty\" : \"Unclosed\"} character class`\n  );\n}\nfunction throwIfUnclosedGroup(token2) {\n  return throwIfNot(token2, \"Unclosed group\");\n}\n\n// node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\nvar Context = Object.freeze({\n  DEFAULT: \"DEFAULT\",\n  CHAR_CLASS: \"CHAR_CLASS\"\n});\nfunction replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, \"gsu\");\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = \"\";\n  for (const match of expression.matchAll(re)) {\n    const { 0: m, groups: { $skip } } = match;\n    if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1]\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === \"[\") {\n      numCharClassesOpen++;\n      negated.push(m[1] === \"^\");\n    } else if (m === \"]\" && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\nfunction forEachUnescaped(expression, needle, callback, context) {\n  replaceUnescaped(expression, needle, callback, context);\n}\nfunction execUnescaped(expression, needle, pos = 0, context) {\n  if (!new RegExp(needle, \"su\").test(expression)) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, \"gsu\");\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const { 0: m, groups: { $skip } } = match;\n    if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === \"[\") {\n      numCharClassesOpen++;\n    } else if (m === \"]\" && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\nfunction hasUnescaped(expression, needle, context) {\n  return !!execUnescaped(expression, needle, 0, context);\n}\nfunction getGroupContents(expression, contentsStartPos) {\n  const token2 = /\\\\?./gsu;\n  token2.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token2.exec(expression)) {\n    const [m] = match;\n    if (m === \"[\") {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === \"(\") {\n        numGroupsOpen++;\n      } else if (m === \")\") {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === \"]\") {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n\n// node_modules/.pnpm/regex@5.0.2/node_modules/regex/src/subclass.js\nvar emulationGroupMarker = \"$E$\";\nvar RegExpSubclass = class _RegExpSubclass extends RegExp {\n  /**\n  Avoid `#private` to allow for subclassing.\n  @private\n  @type {Array<boolean> | undefined}\n  */\n  _captureMap;\n  /**\n  @param {string | RegExpSubclass} expression\n  @param {string} [flags]\n  @param {{useEmulationGroups: boolean;}} [options]\n  */\n  constructor(expression, flags, options) {\n    if (expression instanceof RegExp && options) {\n      throw new Error(\"Cannot provide options when copying regexp\");\n    }\n    let captureMap;\n    if (options?.useEmulationGroups) {\n      ({ expression, captureMap } = unmarkEmulationGroups(expression));\n    }\n    super(expression, flags);\n    if (captureMap) {\n      this._captureMap = captureMap;\n    } else if (expression instanceof _RegExpSubclass) {\n      this._captureMap = expression._captureMap;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const match = RegExp.prototype.exec.call(this, str);\n    if (!match || !this._captureMap) {\n      return match;\n    }\n    const matchCopy = [...match];\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    for (let i = 1; i < matchCopy.length; i++) {\n      if (this._captureMap[i]) {\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n    }\n    return match;\n  }\n};\nfunction unmarkEmulationGroups(expression) {\n  const marker = emulationGroupMarker.replace(/\\$/g, \"\\\\$\");\n  const captureMap = [true];\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\((?:(?!\\?)|\\?<(?![=!])[^>]+>)(?<mark>${marker})?`,\n    ({ 0: m, groups: { mark } }) => {\n      if (mark) {\n        captureMap.push(false);\n        return m.slice(0, -emulationGroupMarker.length);\n      }\n      captureMap.push(true);\n      return m;\n    },\n    Context.DEFAULT\n  );\n  return {\n    captureMap,\n    expression\n  };\n}\n\n// node_modules/.pnpm/regex@5.0.2/node_modules/regex/src/utils-internals.js\nvar noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\n// node_modules/.pnpm/regex@5.0.2/node_modules/regex/src/atomic.js\nvar atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, \"gsu\");\nfunction atomic(expression, data) {\n  if (!/\\(\\?>/.test(expression)) {\n    return expression;\n  }\n  const aGDelim = \"(?>\";\n  const emulatedAGDelim = `(?:(?=(${data?.useEmulationGroups ? emulationGroupMarker : \"\"}`;\n  const captureNumMap = [0];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const { 0: m, index, groups: { capturingStart, noncapturingStart } } = match;\n      if (m === \"[\") {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === \")\" && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${expression.slice(aGPos + aGDelim.length, index)}))<$$${numAGs + numCapturesBeforeAG}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n      } else if (m === \"]\") {\n        numCharClassesOpen--;\n      }\n    }\n  } while (hasProcessedAG);\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({ 0: m, groups: { backrefNum, wrappedBackrefNum } }) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    Context.DEFAULT\n  );\n  return expression;\n}\nvar baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\nvar possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, \"\"), \"gsu\");\nfunction possessive(expression) {\n  if (!new RegExp(`${baseQuantifier}\\\\+`).test(expression)) {\n    return expression;\n  }\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = \"\";\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const { 0: m, index, groups: { qBase, qMod, invalidQ } } = match;\n    if (m === \"[\") {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === \"]\") {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n      if (qMod === \"+\" && lastToken && !lastToken.startsWith(\"(\")) {\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1;\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = spliceStr(expression, index + qBase.length, qMod, \"\");\n        } else {\n          if (lastToken === \")\" || lastToken === \"]\") {\n            const nodeIndex = lastToken === \")\" ? lastGroupIndex : lastCharClassIndex;\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4;\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === \"(\") {\n        openGroupIndices.push(index);\n      } else if (m === \")\") {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n    }\n    lastToken = m;\n  }\n  return expression;\n}\n\n// src/subclass.js\nfunction applySubclassStrategies(ast) {\n  const alts = ast.pattern.alternatives;\n  const firstEl = alts[0].elements[0];\n  if (alts.length > 1 || !firstEl) {\n    return null;\n  }\n  const hasWrapperGroup = hasOnlyChild(ast.pattern, (kid) => kid.type === AstTypes.CapturingGroup || kid.type === AstTypes.Group) && firstEl.alternatives.length === 1;\n  const singleAltIn = hasWrapperGroup ? firstEl.alternatives[0] : alts[0];\n  const firstElIn = hasWrapperGroup ? singleAltIn.elements[0] : firstEl;\n  if (!firstElIn) {\n    return null;\n  }\n  if ((firstElIn.type === AstTypes.CapturingGroup || firstElIn.type === AstTypes.Group) && firstElIn.alternatives.length === 2 && firstElIn.alternatives[0].elements.length === 1 && firstElIn.alternatives[1].elements.length === 1) {\n    const el1 = firstElIn.alternatives[0].elements[0];\n    const el2 = firstElIn.alternatives[1].elements[0];\n    if (el1.kind === AstAssertionKinds.line_start && el2.kind === AstAssertionKinds.search_start || el1.kind === AstAssertionKinds.search_start && el2.kind === AstAssertionKinds.line_start) {\n      if (el1.kind === AstAssertionKinds.line_start) {\n        firstElIn.alternatives.pop();\n      } else {\n        firstElIn.alternatives.shift();\n      }\n      return \"line_or_search_start\";\n    }\n  }\n  if (isLoneGLookaround(firstElIn, { negate: true })) {\n    firstElIn.parent.elements.shift();\n    return \"not_search_start\";\n  }\n  for (let i = 0; i < singleAltIn.elements.length; i++) {\n    const el = singleAltIn.elements[i];\n    if (!isZeroLengthNode(el)) {\n      break;\n    }\n    if (isLoneGLookaround(el, { negate: true })) {\n      singleAltIn.elements.splice(i, 1);\n      return \"not_search_start\";\n    }\n  }\n  return null;\n}\nvar EmulatedRegExp = class _EmulatedRegExp extends RegExpSubclass {\n  #strategy;\n  /**\n  @param {string | EmulatedRegExp} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  constructor(pattern, flags, options) {\n    const opts = {\n      useEmulationGroups: false,\n      strategy: null,\n      ...options\n    };\n    super(pattern, flags, { useEmulationGroups: opts.useEmulationGroups });\n    if (opts.strategy) {\n      this.#strategy = opts.strategy;\n    } else if (pattern instanceof _EmulatedRegExp) {\n      this.#strategy = pattern.#strategy;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const exec = super.exec;\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n    const strategy = this.#strategy;\n    if (strategy === \"line_or_search_start\" && useLastIndex && this.lastIndex) {\n      this.lastIndex = 0;\n      const match = exec.call(this, str.slice(pos));\n      if (match) {\n        match.input = str;\n        match.index += pos;\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n    if (strategy === \"not_search_start\") {\n      let match = exec.call(this, str);\n      if (match?.index === pos) {\n        const globalRe = useLastIndex ? this : new RegExp(this.source, `g${this.flags}`);\n        globalRe.lastIndex = match.index + 1;\n        match = exec.call(globalRe, str);\n      }\n      return match;\n    }\n    return exec.call(this, str);\n  }\n};\nfunction isLoneGLookaround(node, options) {\n  return isLookaround(node) && node.negate === options.negate && hasOnlyChild(node, (kid) => kid.kind === AstAssertionKinds.search_start);\n}\n\n// node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs\nvar r2 = String.raw;\nvar seq = r2`(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})`;\nvar sTags = r2`\\u{E0061}-\\u{E007A}`;\nvar emoji_regex_xs_default = () => new RegExp(r2`[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[${sTags}]{2}[\\u{E0030}-\\u{E0039}${sTags}]{1,3}\\u{E007F}|${seq}(?:\\u200D${seq})*`, \"gu\");\n\n// src/transform.js\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `VariableLengthCharacterSet` kind `grapheme` (`\\X`): An exact representation would require\n    //   heavy Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: \"default\",\n    allowUnhandledGAnchors: false,\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: \"ES2025\",\n    ...options\n  };\n  const strategy = opts.avoidSubclass ? null : applySubclassStrategies(ast);\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    allowUnhandledGAnchors: opts.allowUnhandledGAnchors,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    flagDirectivesByAlt: /* @__PURE__ */ new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, \"ES2024\"),\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: /* @__PURE__ */ new Map(),\n    supportedGNodes: /* @__PURE__ */ new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii\n  };\n  traverse({ node: ast }, firstPassState, FirstPassVisitor);\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase\n  };\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: /* @__PURE__ */ new Map(),\n    groupsByName: /* @__PURE__ */ new Map(),\n    multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),\n    openRefs: /* @__PURE__ */ new Map(),\n    reffedNodesByReferencer: /* @__PURE__ */ new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap\n  };\n  traverse({ node: ast }, secondPassState, SecondPassVisitor);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer\n  };\n  traverse({ node: ast }, thirdPassState, ThirdPassVisitor);\n  if (strategy) {\n    ast._strategy = strategy;\n  }\n  return ast;\n}\nvar FirstPassVisitor = {\n  Alternative: {\n    enter({ node, parent, key }, { flagDirectivesByAlt }) {\n      const flagDirectives = node.elements.filter((el) => el.kind === AstDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrCreate(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({ node }, { flagDirectivesByAlt }) {\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = prepContainer(createGroup({ flags }), node.elements);\n          flagGroup.parent = node;\n          node.elements = [flagGroup];\n        }\n      }\n    }\n  },\n  Assertion({ node, ast, remove, replaceWith }, { allowUnhandledGAnchors, asciiWordBoundaries, supportedGNodes, wordIsAscii }) {\n    const { kind, negate } = node;\n    if (kind === AstAssertionKinds.line_end) {\n      replaceWith(parseFragment(r`(?=\\z|\\n)`));\n    } else if (kind === AstAssertionKinds.line_start) {\n      replaceWith(parseFragment(r`(?<=\\A|\\n(?!\\z))`));\n    } else if (kind === AstAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        ast.flags.sticky = true;\n      } else if (!allowUnhandledGAnchors) {\n        throw new Error(r`Uses \"\\G\" in a way that's unsupported`);\n      }\n      remove();\n    } else if (kind === AstAssertionKinds.string_end_newline) {\n      replaceWith(parseFragment(r`(?=\\n?\\z)`));\n    } else if (kind === AstAssertionKinds.word_boundary && !wordIsAscii && !asciiWordBoundaries) {\n      const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n      const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n      replaceWith(parseFragment(negate ? B : b));\n    }\n  },\n  CapturingGroup({ node }, { subroutineRefMap }) {\n    const { name, number } = node;\n    if (name && !isValidGroupNameJs(name)) {\n      throw new Error(`Group name \"${name}\" invalid in JS`);\n    }\n    subroutineRefMap.set(number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n  CharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n    const { kind, negate, value } = node;\n    if (digitIsAscii && (kind === AstCharacterSetKinds.digit || value === \"digit\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.digit, { negate }));\n      return;\n    }\n    if (spaceIsAscii && (kind === AstCharacterSetKinds.space || value === \"space\")) {\n      replaceWith(setNegate(parseFragment(asciiSpaceChar), negate));\n      return;\n    }\n    if (wordIsAscii && (kind === AstCharacterSetKinds.word || value === \"word\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.word, { negate }));\n      return;\n    }\n    if (kind === AstCharacterSetKinds.any) {\n      replaceWith(createUnicodeProperty(\"Any\"));\n    } else if (kind === AstCharacterSetKinds.digit) {\n      replaceWith(createUnicodeProperty(\"Nd\", { negate }));\n    } else if (kind === AstCharacterSetKinds.hex) {\n      replaceWith(createUnicodeProperty(\"AHex\", { negate }));\n    } else if (kind === AstCharacterSetKinds.non_newline) {\n      replaceWith(parseFragment(r`[^\\n]`));\n    } else if (kind === AstCharacterSetKinds.space) {\n      replaceWith(createUnicodeProperty(\"space\", { negate }));\n    } else if (kind === AstCharacterSetKinds.word) {\n      replaceWith(setNegate(parseFragment(defaultWordChar), negate));\n    } else if (kind === AstCharacterSetKinds.property) {\n      if (!JsUnicodeProperties.has(value)) {\n        node.key = \"sc\";\n      }\n    } else if (kind === AstCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === \"graph\" || value === \"print\")) {\n        if (accuracy === \"strict\") {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: \"!-~\",\n          print: \" -~\"\n        }[value];\n        if (negate) {\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(parseFragment(`[${ascii}]`));\n      } else {\n        replaceWith(setNegate(parseFragment(PosixClassesMap.get(value)), negate));\n      }\n    }\n  },\n  Directive(path, state) {\n    const { node, parent, ast, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings } = path;\n    const { kind, flags } = node;\n    if (kind === AstDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        remove();\n      } else {\n        const flagGroup = prepContainer(createGroup({ flags }), removeAllNextSiblings());\n        replaceWith(flagGroup);\n        traverseReplacement(flagGroup, path, state, FirstPassVisitor);\n      }\n    } else if (kind === AstDirectiveKinds.keep) {\n      if (parent.parent !== ast.pattern || ast.pattern.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(prepContainer(createLookaround({ behind: true }), removeAllPrevSiblings()));\n    }\n  },\n  Flags({ node, parent }) {\n    [\n      \"digitIsAscii\",\n      // Flag D\n      \"extended\",\n      // Flag x\n      \"spaceIsAscii\",\n      // Flag S\n      \"wordIsAscii\"\n      // Flag W\n    ].forEach((f) => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, set intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true\n      }\n    };\n  },\n  Group({ node }) {\n    if (!node.flags) {\n      return;\n    }\n    const { enable, disable } = node.flags;\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n  Pattern({ node }, { allowUnhandledGAnchors, supportedGNodes }) {\n    const leadingGs = [];\n    let hasAltWithLeadG = false;\n    let hasAltWithoutLeadG = false;\n    for (const alt of node.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (leadingG) {\n        hasAltWithLeadG = true;\n        Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);\n      } else {\n        hasAltWithoutLeadG = true;\n      }\n    }\n    if (hasAltWithLeadG) {\n      if (!hasAltWithoutLeadG) {\n        leadingGs.forEach((g) => supportedGNodes.add(g));\n      } else if (!allowUnhandledGAnchors) {\n        throw new Error(r`Uses \"\\G\" in a way that's unsupported`);\n      }\n    }\n  },\n  Quantifier({ node }) {\n    if (node.element.type === AstTypes.Quantifier) {\n      const group = prepContainer(createGroup(), [node.element]);\n      group.parent = node;\n      node.element = group;\n    }\n  },\n  VariableLengthCharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024 }) {\n    const { kind } = node;\n    if (kind === AstVariableLengthCharacterSetKinds.newline) {\n      replaceWith(parseFragment(\"(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])\"));\n    } else if (kind === AstVariableLengthCharacterSetKinds.grapheme) {\n      if (accuracy === \"strict\") {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : emoji_regex_xs_default().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      replaceWith(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, { skipPropertyNameValidation: true }));\n    } else {\n      throw new Error(`Unexpected varcharset kind \"${kind}\"`);\n    }\n  }\n};\nvar SecondPassVisitor = {\n  Backreference({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {\n    const { orphan, ref } = node;\n    if (!orphan) {\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 }) => node2)]);\n    }\n  },\n  Recursion({ node, parent }, { reffedNodesByReferencer }) {\n    const { ref } = node;\n    let reffed = parent;\n    while (reffed = reffed.parent) {\n      if (reffed.type === AstTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    reffedNodesByReferencer.set(node, reffed);\n  },\n  CapturingGroup: {\n    enter({\n      node,\n      replaceWith,\n      skip\n    }, {\n      groupOriginByCopy,\n      groupsByName,\n      multiplexCapturesToLeftByRef,\n      openRefs,\n      reffedNodesByReferencer\n    }) {\n      const origin = groupOriginByCopy.get(node);\n      if (origin && openRefs.has(node.number)) {\n        const recursion2 = createRecursion(node.number);\n        reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));\n        replaceWith(recursion2);\n        skip();\n        return;\n      }\n      openRefs.set(node.number, node);\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrCreate(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({ node, origin });\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({ node, origin });\n      }\n      if (node.name) {\n        const groupsWithSameName = getOrCreate(groupsByName, node.name, /* @__PURE__ */ new Map());\n        for (const groupInfo of groupsWithSameName.values()) {\n          if (!groupInfo.hasDuplicateNameToRemove && canParticipateWithNode(groupInfo.node, node, {\n            ancestorsParticipate: true\n          })) {\n            groupInfo.hasDuplicateNameToRemove = true;\n          }\n        }\n        groupsByName.get(node.name).set(node, { node });\n      }\n    },\n    exit({ node }, { openRefs }) {\n      openRefs.delete(node.number);\n    }\n  },\n  Group: {\n    enter({ node }, state) {\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    }\n  },\n  Subroutine(path, state) {\n    const { node, replaceWith } = path;\n    const { ref } = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : (\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null)\n    );\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (node2) => {\n        return node2.type === AstTypes.Group && !!node2.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags)\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(replacement);\n    if (!isGlobalRecursion) {\n      traverseReplacement(replacement, path, state, SecondPassVisitor);\n    }\n  }\n};\nvar ThirdPassVisitor = {\n  Backreference({ node, replaceWith }, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter((reffed) => canParticipateWithNode(reffed, node, {\n      ancestorsParticipate: false\n    }));\n    if (!participants.length) {\n      replaceWith(createLookaround({ negate: true }));\n    } else if (participants.length > 1) {\n      const alts = participants.map((reffed) => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(adoptAndSwapKids(createGroup(), alts));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n  CapturingGroup({ node }, state) {\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n  Recursion({ node }, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n  Regex: {\n    exit({ node }, state) {\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    }\n  }\n};\nvar asciiSpaceChar = \"[\t-\\r ]\";\nvar defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach((kid) => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\nfunction canParticipateWithNode(capture, node, { ancestorsParticipate }) {\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === AstTypes.Pattern) {\n      return false;\n    }\n    if (rightmostPoint.type === AstTypes.Alternative) {\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      return ancestorsParticipate;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while (rightmostPoint = rightmostPoint.parent);\n  throw new Error(\"Unexpected path\");\n}\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === \"parent\") {\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === \"object\") {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === \"type\" && value === AstTypes.CapturingGroup) {\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\nfunction createRecursion(ref) {\n  return {\n    type: AstTypes.Recursion,\n    ref\n  };\n}\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while (node = node.parent) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\nfunction getContainerAccessor(node) {\n  for (const accessor of [\"alternatives\", \"classes\", \"elements\"]) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = [\"dotAll\", \"ignoreCase\"];\n  const combinedFlags = { enable: {}, disable: {} };\n  flagNodes.forEach(({ flags }) => {\n    flagProps.forEach((prop) => {\n      if (flags.enable?.[prop]) {\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\nfunction getFlagModsFromFlags({ dotAll, ignoreCase }) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\nfunction getKids(node) {\n  if (!node) {\n    throw new Error(\"Node expected\");\n  }\n  if (node.type === AstTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\nfunction getLeadingG(els) {\n  const firstToConsider = els.find((el) => el.kind === AstAssertionKinds.search_start || isLoneGLookaround(el, { negate: false }) || !isZeroLengthNode(el));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === AstAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (isLookaround(firstToConsider)) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (firstToConsider.type === AstTypes.Group || firstToConsider.type === AstTypes.CapturingGroup) {\n    const gNodesForGroup = [];\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        return null;\n      }\n      Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (kid === descendant || hasDescendant(kid, descendant)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isValidGroupNameJs(name) {\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\nfunction parseFragment(pattern, options) {\n  const ast = parse(tokenize(pattern), options);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\nfunction traverseReplacement(replacement, { parent, key, container }, state, visitor) {\n  traverse({\n    // Don't use the `node` from `path`\n    node: replacement,\n    parent,\n    key,\n    container\n  }, state, visitor);\n}\n\n// src/generate.js\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, \"ES2024\");\n  const minTargetEs2025 = isMinTarget(opts.target, \"ES2025\");\n  const rDepth = opts.maxRecursionDepth;\n  if (rDepth !== null && (!Number.isInteger(rDepth) || rDepth < 2 || rDepth > 100)) {\n    throw new Error(\"Invalid maxRecursionDepth; use 2-100 or null\");\n  }\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse({ node: ast }, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {\n        iStack.pop();\n      },\n      pushModI(isIOn) {\n        iStack.push(isIOn);\n      },\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      }\n    }, FlagModifierVisitor);\n  }\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    captureFlagIMap: /* @__PURE__ */ new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase\n    },\n    groupNames: /* @__PURE__ */ new Set(),\n    inCharClass: false,\n    lastNode,\n    maxRecursionDepth: rDepth,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useDuplicateNames: minTargetEs2025,\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    usePostEs2018Properties: minTargetEs2024,\n    verbose: opts.verbose\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case AstTypes.Regex:\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: { ...node.options }\n        };\n      case AstTypes.Alternative:\n        return node.elements.map(gen).join(\"\");\n      case AstTypes.Assertion:\n        return genAssertion(node, state, gen);\n      case AstTypes.Backreference:\n        return genBackreference(node, state);\n      case AstTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case AstTypes.Character:\n        return genCharacter(node, state);\n      case AstTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case AstTypes.CharacterClassIntersection:\n        if (!state.useFlagV) {\n          throw new Error(\"Use of class intersection requires min target ES2024\");\n        }\n        return node.classes.map(gen).join(\"&&\");\n      case AstTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case AstTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case AstTypes.Flags:\n        return genFlags(node, state);\n      case AstTypes.Group:\n        return genGroup(node, state, gen);\n      case AstTypes.Pattern:\n        return node.alternatives.map(gen).join(\"|\");\n      case AstTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case AstTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  return result;\n}\nvar FlagModifierVisitor = {\n  AnyGroup: {\n    enter({ node }, state) {\n      const currentModI = state.getCurrentModI();\n      state.pushModI(\n        node.flags ? getNewCurrentFlags({ ignoreCase: currentModI }, node.flags).ignoreCase : currentModI\n      );\n    },\n    exit(_, state) {\n      state.popModI();\n    }\n  },\n  Backreference(_, state) {\n    state.setHasCasedChar();\n  },\n  Character({ node }, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({ node, skip }, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, { firstOnly: true }).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({ node }, state) {\n    if (node.kind === AstCharacterSetKinds.property && UnicodePropertiesWithSpecificCase.has(node.value)) {\n      state.setHasCasedChar();\n    }\n  }\n};\nvar BaseEscapeChars = /* @__PURE__ */ new Set([\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\"\n]);\nvar CharClassEscapeChars = /* @__PURE__ */ new Set([\n  \"-\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  \"[\"\n]);\nvar CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([\n  \"(\",\n  \")\",\n  \"-\",\n  \"/\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\",\n  // Double punctuators; also includes already-listed `-` and `^`\n  \"!\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"&\",\n  \"*\",\n  \"+\",\n  \",\",\n  \".\",\n  \":\",\n  \";\",\n  \"<\",\n  \"=\",\n  \">\",\n  \"?\",\n  \"@\",\n  \"`\",\n  \"~\"\n]);\nvar CharCodeEscapeMap = /* @__PURE__ */ new Map([\n  [9, r`\\t`],\n  // horizontal tab\n  [10, r`\\n`],\n  // line feed\n  [11, r`\\v`],\n  // vertical tab\n  [12, r`\\f`],\n  // form feed\n  [13, r`\\r`],\n  // carriage return\n  [8232, r`\\u2028`],\n  // line separator\n  [8233, r`\\u2029`],\n  // paragraph separator\n  [65279, r`\\uFEFF`]\n  // ZWNBSP/BOM\n]);\nvar casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\nfunction genAssertion(node, _, gen) {\n  const { kind, negate, alternatives } = node;\n  if (isLookaround(node)) {\n    const prefix = `${kind === AstAssertionKinds.lookahead ? \"\" : \"<\"}${negate ? \"!\" : \"=\"}`;\n    return `(?${prefix}${alternatives.map(gen).join(\"|\")})`;\n  }\n  if (kind === AstAssertionKinds.string_end) {\n    return \"$\";\n  }\n  if (kind === AstAssertionKinds.string_start) {\n    return \"^\";\n  }\n  if (kind === AstAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\nfunction genBackreference({ ref }, state) {\n  if (typeof ref !== \"number\") {\n    throw new Error(\"Unexpected named backref in transformed AST\");\n  }\n  if (!state.useFlagMods && state.accuracy === \"strict\" && state.currentFlags.ignoreCase && !state.captureFlagIMap.get(ref)) {\n    throw new Error(\"Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy\");\n  }\n  return \"\\\\\" + ref;\n}\nfunction genCapturingGroup({ name, number, alternatives }, state, gen) {\n  if (name) {\n    if (state.groupNames.has(name)) {\n      if (!state.useDuplicateNames) {\n        name = null;\n      }\n    } else {\n      state.groupNames.add(name);\n    }\n  }\n  state.captureFlagIMap.set(number, state.currentFlags.ignoreCase);\n  return `(${name ? `?<${name}>` : \"\"}${alternatives.map(gen).join(\"|\")})`;\n}\nfunction genCharacter({ value }, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    isAfterBackref: state.lastNode.type === AstTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ? cases.join(\"\") : cases.length > 1 ? `[${cases.join(\"\")}]` : cases[0];\n  }\n  return char;\n}\nfunction genCharacterClass({ negate, parent, elements }, state, gen) {\n  const genClass = () => `[${negate ? \"^\" : \"\"}${elements.map(gen).join(\"\")}]`;\n  if (!state.inCharClass) {\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  const firstType = elements[0].type;\n  if (!negate && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n  ((!state.useFlagV || !state.verbose) && parent.type === AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassIntersection) || !state.verbose && parent.type === AstTypes.CharacterClassIntersection && elements.length === 1 && firstType !== AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassRange) {\n    return elements.map(gen).join(\"\");\n  }\n  if (!state.useFlagV && parent.type === AstTypes.CharacterClass) {\n    throw new Error(\"Use of nested character class requires min target ES2024\");\n  }\n  return genClass();\n}\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    isAfterBackref: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  let extraChars = \"\";\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach((value) => {\n      extraChars += Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts);\n    });\n  }\n  return `${minStr}-${maxStr}${extraChars}`;\n}\nfunction genCharacterSet({ kind, negate, value, key }, state) {\n  if (kind === AstCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? \".\" : \"[^]\" : (\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`\n    );\n  }\n  if (kind === AstCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === AstCharacterSetKinds.property) {\n    if (!state.usePostEs2018Properties && JsUnicodePropertiesPostEs2018.has(value)) {\n      throw new Error(`Unicode property \"${value}\" unavailable in target ES2018`);\n    }\n    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : \"\"}${value}}`;\n  }\n  if (kind === AstCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? \"i\" : \"\") + (node.dotAll ? \"s\" : \"\") + (node.sticky ? \"y\" : \"\")\n  );\n}\nfunction genGroup({ atomic: atomic2, flags, parent, alternatives }, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join(\"|\");\n  const result = !state.verbose && alternatives.length === 1 && parent.type !== AstTypes.Quantifier && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\nfunction genRecursion({ ref }, state) {\n  const rDepth = state.maxRecursionDepth;\n  if (!rDepth) {\n    throw new Error(\"Use of recursion disabled\");\n  }\n  if (state.accuracy === \"strict\") {\n    throw new Error(\"Use of recursion requires non-strict accuracy due to depth limit\");\n  }\n  return ref === 0 ? `(?R=${rDepth})` : r`\\g<${ref}&R=${rDepth}>`;\n}\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar) => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\nfunction getCharEscape(codePoint, { isAfterBackref, inCharClass, useFlagV }) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    isAfterBackref && isDigitCharCode(codePoint)\n  ) {\n    return codePoint > 255 ? `\\\\u{${codePoint.toString(16).toUpperCase()}}` : `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, \"0\")}`;\n  }\n  const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? \"\\\\\" : \"\") + char;\n}\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map((char) => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\nfunction getGroupPrefix(atomic2, flagMods, useFlagMods) {\n  if (atomic2) {\n    return \">\";\n  }\n  let mods = \"\";\n  if (flagMods && useFlagMods) {\n    const { enable, disable } = flagMods;\n    mods = (enable?.ignoreCase ? \"i\" : \"\") + (enable?.dotAll ? \"s\" : \"\") + (disable ? \"-\" : \"\") + (disable?.ignoreCase ? \"i\" : \"\") + (disable?.dotAll ? \"s\" : \"\");\n  }\n  return `${mods}:`;\n}\nfunction getQuantifierStr({ min, max, greedy, possessive: possessive2 }) {\n  let base;\n  if (!min && max === 1) {\n    base = \"?\";\n  } else if (!min && max === Infinity) {\n    base = \"*\";\n  } else if (min === 1 && max === Infinity) {\n    base = \"+\";\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? \"\" : max}}`;\n  }\n  return base + (possessive2 ? \"+\" : greedy ? \"\" : \"?\");\n}\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\n// node_modules/.pnpm/regex-recursion@5.0.0/node_modules/regex-recursion/src/index.js\nvar r3 = String.raw;\nvar gRToken = r3`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nvar recursiveToken = r3`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nvar namedCapturingDelim = r3`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nvar token = new RegExp(r3`${namedCapturingDelim}|${recursiveToken}|\\(\\?|\\\\?.`, \"gsu\");\nvar overlappingRecursionMsg = \"Cannot use multiple overlapping recursions\";\nvar emulationGroupMarker2 = \"$E$\";\nfunction recursion(expression, data) {\n  if (!new RegExp(recursiveToken, \"su\").test(expression)) {\n    return expression;\n  }\n  if (hasUnescaped(expression, r3`\\(\\?\\(DEFINE\\)`, Context.DEFAULT)) {\n    throw new Error(\"DEFINE groups cannot be used with recursion\");\n  }\n  const useEmulationGroups = !!data?.useEmulationGroups;\n  const hasNumberedBackref = hasUnescaped(expression, r3`\\\\[1-9]`, Context.DEFAULT);\n  const groupContentsStartPos = /* @__PURE__ */ new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  token.lastIndex = 0;\n  while (match = token.exec(expression)) {\n    const { 0: m, groups: { captureName, rDepth, gRNameOrNum, gRDepth } } = match;\n    if (m === \"[\") {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          throw new Error(\"Numbered backrefs cannot be used with global recursion\");\n        }\n        const pre = expression.slice(0, match.index);\n        const post = expression.slice(token.lastIndex);\n        if (hasUnescaped(post, recursiveToken, Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        return makeRecursive(pre, post, +rDepth, false, useEmulationGroups);\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r3`Recursive \\g cannot be used outside the referenced group \"\\g<${gRNameOrNum}&R=${gRDepth}>\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = getGroupContents(expression, startPos);\n        if (hasNumberedBackref && hasUnescaped(groupContents, r3`${namedCapturingDelim}|\\((?!\\?)`, Context.DEFAULT)) {\n          throw new Error(\"Numbered backrefs cannot be used with recursion of capturing groups\");\n        }\n        const groupContentsPre = expression.slice(startPos, match.index);\n        const groupContentsPost = groupContents.slice(groupContentsPre.length + m.length);\n        const expansion = makeRecursive(groupContentsPre, groupContentsPost, +gRDepth, true, useEmulationGroups);\n        const pre = expression.slice(0, startPos);\n        const post = expression.slice(startPos + groupContents.length);\n        expression = `${pre}${expansion}${post}`;\n        token.lastIndex += expansion.length - m.length - groupContentsPre.length - groupContentsPost.length;\n        openGroups.forEach((g) => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCaptures++;\n        groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCaptures,\n          name: captureName\n        });\n      } else if (m.startsWith(\"(\")) {\n        const isUnnamedCapture = m === \"(\";\n        if (isUnnamedCapture) {\n          numCaptures++;\n          groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        }\n        openGroups.push(isUnnamedCapture ? { num: numCaptures } : {});\n      } else if (m === \")\") {\n        openGroups.pop();\n      }\n    } else if (m === \"]\") {\n      numCharClassesOpen--;\n    }\n  }\n  return expression;\n}\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\nfunction makeRecursive(pre, post, maxDepth, isSubpattern, useEmulationGroups) {\n  const namesInRecursed = /* @__PURE__ */ new Set();\n  if (isSubpattern) {\n    forEachUnescaped(pre + post, namedCapturingDelim, ({ groups: { captureName } }) => {\n      namesInRecursed.add(captureName);\n    }, Context.DEFAULT);\n  }\n  const reps = maxDepth - 1;\n  return `${pre}${repeatWithDepth(`(?:${pre}`, reps, isSubpattern ? namesInRecursed : null, \"forward\", useEmulationGroups)}(?:)${repeatWithDepth(`${post})`, reps, isSubpattern ? namesInRecursed : null, \"backward\", useEmulationGroups)}${post}`;\n}\nfunction repeatWithDepth(expression, reps, namesInRecursed, direction, useEmulationGroups) {\n  const startNum = 2;\n  const depthNum = (i) => direction === \"backward\" ? reps - i + startNum - 1 : i + startNum;\n  let result = \"\";\n  for (let i = 0; i < reps; i++) {\n    const captureNum = depthNum(i);\n    result += replaceUnescaped(\n      expression,\n      r3`${namedCapturingDelim}|\\\\k<(?<backref>[^>]+)>${useEmulationGroups ? r3`|\\((?!\\?)` : \"\"}`,\n      ({ 0: m, groups: { captureName, backref } }) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          return m;\n        }\n        if (m === \"(\") {\n          return `(${emulationGroupMarker2}`;\n        }\n        const suffix = `_$${captureNum}`;\n        return captureName ? `(?<${captureName}${suffix}>${useEmulationGroups ? emulationGroupMarker2 : \"\"}` : r3`\\k<${backref}${suffix}>`;\n      },\n      Context.DEFAULT\n    );\n  }\n  return result;\n}\n\n// src/index.js\nfunction toDetails(pattern, options) {\n  const opts = getOptions(options);\n  const tokenized = tokenize(pattern, opts.flags, { captureGroup: opts.rules.captureGroup });\n  const onigurumaAst = parse(tokenized, {\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    verbose: opts.verbose\n  });\n  const regexAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    allowUnhandledGAnchors: opts.rules.allowUnhandledGAnchors,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    bestEffortTarget: opts.target\n  });\n  const generated = generate(regexAst, opts);\n  const pluginData = { useEmulationGroups: !opts.avoidSubclass };\n  const result = {\n    pattern: atomic(possessive(recursion(generated.pattern, pluginData)), pluginData),\n    flags: `${opts.hasIndices ? \"d\" : \"\"}${opts.global ? \"g\" : \"\"}${generated.flags}${generated.options.disable.v ? \"u\" : \"v\"}`\n  };\n  const emulationGroupMarker3 = \"$E$\";\n  const useEmulationGroups = result.pattern.includes(emulationGroupMarker3) && !opts.avoidSubclass;\n  if (useEmulationGroups || regexAst._strategy) {\n    result.subclass = {\n      useEmulationGroups,\n      strategy: regexAst._strategy ?? null\n    };\n  }\n  return result;\n}\nfunction toOnigurumaAst(pattern, options) {\n  const flags = options?.flags ?? \"\";\n  const captureGroup = options?.rules?.captureGroup ?? false;\n  return parse(tokenize(pattern, flags, { captureGroup }));\n}\nfunction toRegExp(pattern, options) {\n  const result = toDetails(pattern, options);\n  if (result.subclass) {\n    return new EmulatedRegExp(result.pattern, result.flags, result.subclass);\n  }\n  return new RegExp(result.pattern, result.flags);\n}\nexport {\n  EmulatedRegExp,\n  toDetails,\n  toOnigurumaAst,\n  toRegExp\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":[],"sourceRoot":""}